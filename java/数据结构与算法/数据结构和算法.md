---
title: 数据结构和算法

author: seven

avatar: https://sevenpic.oss-cn-beijing.aliyuncs.com/img/seven.jpg

authorLink: yjl.cool

authorAbout: 不懂猫，更不懂开发的人

authorDesc: 

categories: 技术

comments: true

date: 2021-08-23 22:20:28

tags: 

keywords: 

description: null

photos: null

---
# 数据结构和算法
## 数组队列
   ### 1.完成数组模拟队列

      设计思路：定义一个数组，定义一个指向头元素的head -1，定义一个指向尾部tail -1。
      
      * 存储的大小：tail-head
      * 是否为空：tail=head
      * 是否满了：tail-head=size
      * 添加：tail+1，将数组下标为tail加入数组
      * 取出：head+1，返回head数组对应元素
      * 查看最外层元素：先判断是否为空，返回head对应

   >存在问题：

   * 当数组大小为3，tail为2也就是存储过了3个，而head为1也就是取出来2个，肯定没有满[2-1=1]，还能存储两个，但是tail再加就是3了会出现数组下标越界。
     * 所以引出环形思想
     * 也可以用if来判断

   ### 2.完成数组模拟环形队列
      设计思路：定义一个数组，定义一个头指针head -1，定义一个尾指针 tail -1。
      * 添加：tail+1，添加到(tail+size)%size位置
      * 取出：head+1，取(head+size)%size
      * 是否为空：tail=head
      * 是的满了：(tail-head+size)%size=0

   ### 3.<div name="4link">完成单链表</div >

      设计思路：需要一共节点对象Node
      
      ```
      属性：
      	public Node next;//执行当前节点的下一个节点
      	private Object value;//当前节点存储的值
      ```
      
      单链表对象：需要一共头节点，方便获取所有节点对象，游标节点next，用于记录当前操作所在节点；
      
      ```
      构造函数：
      	public SingleLink(){
              head=new Node("");
              next=head;
          }
      ```
      
      - 添加：next.next=new Node();并且游标下移一位，next=next.next;
      
      - 更新：先通过头节点遍历，当条件成立进行更新
      
        ```
        public void update(Object oldValue,Object newValue){
                Node temp=head;//临时的游标节点
                while (temp.next!=null){//如果下一个指向不为空表明当前节点temp有值
                    if (temp.next.getValue().equals(oldValue)){//条件
                        temp.next.setValue(newValue);//修改值
                    }
                    temp=temp.next;//游标下移
                }
            }
        ```
      - 删除：同更新
      
        > 问题：他们说链表新增快，没毛病，删除也快？？删除不应先查询再删除嘛？为什么快了？
        因为只需操作指针指向，不需要数组的移动位置，copy数组的操作所以快。
## 链表
### 1.完成有序单链表

- 思路设计：个人认为只需要将<a href="#4link">上面</a>中的node节点添加一共sort属性即可【循序为有小到大】

  ```
  public class NodeSort {
  
      public NodeSort(Object value){
          this.value=value;
      }
      public NodeSort next;
      private Object value;
      private int sort;
  }
  ```

1.1 求单链表中节点个数

1.2 查找单链表中倒数第个节点

​    思路：获取节点个数，找到正数的节点即：整个节点个数-倒数第几个节点，计数遍历

1.3 单链表反转
	 思路：

   - 首先统计出节点个数并创建对应个数的数组，遍历节点，讲每个节点对象存储在数组中，反向变量数组重新添加到头节点
- 首先创建一个零时头节点，通过遍历，每次获取最后一个节点放入新的头节点，最后整合到原来头节点完成反转

1.4 从尾到头打印单链表

* 反向遍历
* 使用栈

1.5 合并两个有序链表，合并后依然有序

### 2.双向链表

DoubleNode对象：

- 前节点、后节点

​	思路：

- 属性分析：头节点
- 方法分析：
  - 

### 3.单向环形链表【约瑟夫问题】

问题引入：有1.2.3.4...n个小朋友做成一圈，从第k个小朋友开始报数，到第m个小朋友出列。又从刚刚出列的小朋友继续报数，到第m个小朋友出列，最后只有一个小朋友完成游戏并加入出列队中。求出列的顺序？
定时炸弹有没有😬

## 栈
需求引入问题：
需求：输入一个计算表达式，输出表达式计算出来的结果
1. 数组模拟栈

2. 链表模拟栈

3. Java中栈是如何设计的？底层是数组还是链表？

   数组vector

4. 实现计算器，实现括号
     注意多位数的处理
### 波兰表达式转化

#### 中缀转后缀

5×(6+3)÷3-1
从左到右依次扫描。

1. 如果是数字
   -  如果不是最后一位，进行下一位嗅探
     -  如果是数字则保存在sb中
     -  否则，将sb的内容入s2栈，并清空sb
   - 否则，直接入s2栈
2. 如果是运算符号
   - 如果s1为空，或者符号为(；符号直接入栈
   - 否则，如果符号是)，依次弹出s1栈并压入s2中，直到弹到( 。如果栈空都没有弹到表达式错误异常
   - 否则，peak s1栈顶
     - 如果栈顶是( ，直接入栈
     - 否则，如果当前运算符大于栈顶运算符，直接入s1栈
     - 否则，【也就是当前运算符小于或者等于栈顶】弹出s1并压入s2中。回到步骤2
3. 将s1剩余的栈依次弹出并压入s2中
4. 每从s1中弹出一个放在sb中就添加一个空格【方便后面计算分割】并进行反转。反转的结果为后缀表达式
   5×(6+3)÷3-1

|  s1  |    s2     |
| :--: | :-------: |
|  *   |     5     |
|  *(  |     5     |
|  *(  |    56     |
| *(+  |    56     |
| *(+  |    563    |
|  *   |   563+    |
|  /   |   563+*   |
|  /   |  563+*3   |
|  -   |  563+*3/  |
|  -   | 563+*3/1  |
|  空  | 563+*3/1- |

#### 后缀转中缀

【这里感觉不用符号栈都行，用一个零时字符来表示】
(6+3)*5/3-1
大致思路：思路错误

1. 如果是数字直接入栈

2. 如果是符号

   2.1如果符号栈s为空直接入栈

   2.2如果当前符号优先级大于s栈栈顶，弹出数字和符号并加入括号，压入数字栈

   2.3否则，直接弹出s栈栈顶，并弹出两个数字，并组合加入数字栈，

#### 后缀表达式计算

5 6 3 + * 3 / 1 -

1. 将后缀表达式对象进行split空格分割；新建数字栈n。
2. 遍历数组并进行数字还是符号判断
3. 如果是数字，直接入栈
4. 如果是符号，弹出n栈的两个数；先出的 运算符 后出的。并压入n栈

#### 

## 递归
1. 递归完成阶乘
2. 完成迷宫回溯问题
	- 如何寻找最短路径？
	- 如何用策略模式设计策略？
3. 8皇后问题


